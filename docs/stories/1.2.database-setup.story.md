# Story 1.2: Database Setup and Data Models

## Status
Draft

## Story
**As a** user,
**I want** my financial data stored in a secure database,
**so that** my information is safe and reliable.

## Acceptance Criteria
1. NeonDB PostgreSQL database is set up and connected to the application
2. Drizzle ORM is configured for type-safe database operations
3. All financial data models are implemented (User, Account, Transaction, Category, RecurringPayment)
4. Database schemas match the architecture specifications with proper relationships
5. Database connection pooling is configured for performance
6. Data integrity constraints are enforced at the database level
7. Database migrations are set up for schema management
8. Database operations are tested with integration tests

## Tasks / Subtasks
- [ ] **Task 1: Set up NeonDB Database Connection** (AC: 1, 5)
  - [ ] Create NeonDB project and database
  - [ ] Configure environment variables for database connection
  - [ ] Set up connection pooling for serverless environment
  - [ ] Test database connectivity

- [ ] **Task 2: Install and Configure Drizzle ORM** (AC: 2, 7)
  - [ ] Install Drizzle ORM and PostgreSQL driver
  - [ ] Configure Drizzle client and connection
  - [ ] Set up Drizzle migration system
  - [ ] Create initial migration structure

- [ ] **Task 3: Implement Core Data Models and Schemas** (AC: 3, 4, 6)
  - [ ] Create User schema matching Clerk integration
  - [ ] Create Account schema with proper types and constraints
  - [ ] Create Transaction schema with decimal precision
  - [ ] Create Category schema with hierarchical support
  - [ ] Create RecurringPayment schema with frequency enums
  - [ ] Implement proper foreign key relationships and constraints

- [ ] **Task 4: Create Database Service Layer** (AC: 2, 6)
  - [ ] Implement repository pattern for database operations
  - [ ] Create type-safe query builders and utilities
  - [ ] Add error handling for database operations
  - [ ] Implement transaction support for financial operations

- [ ] **Task 5: Set up Database Migrations and Seeding** (AC: 7)
  - [ ] Create initial migration with all schemas
  - [ ] Implement migration runner for deployment
  - [ ] Create seed data for default categories
  - [ ] Test migration rollback functionality

- [ ] **Task 6: Testing Database Implementation** (AC: 8)
  - [ ] Write unit tests for schema validation
  - [ ] Write integration tests for database operations
  - [ ] Test connection pooling and performance
  - [ ] Test data integrity constraints
  - [ ] Test migration system

## Dev Notes

### Previous Story Insights
Story 1.1 implemented Clerk authentication successfully. Database integration must work with existing Clerk user IDs and authentication patterns. User synchronization utilities from previous story provide foundation for database user management.

### Database Architecture
**Technology**: NeonDB PostgreSQL Latest for primary data storage [Source: architecture/tech_stack.md]
**Rationale**: ACID compliance for financial transactions, modern PostgreSQL features, serverless scaling [Source: architecture/tech_stack.md]

**Platform Integration**: NeonDB Multi-region with primary in US-East, integrated with Vercel deployment [Source: architecture/architecture.md#Platform and Infrastructure Choice]

**ORM**: Drizzle ORM Latest for type-safe database operations [Source: architecture/architecture.md]
**Rationale**: Type-safe database operations ensuring compile-time error detection for financial data operations [Source: architecture/architecture.md]

### Data Models
**Core Data Models** must implement the following schemas [Source: architecture/architecture.md]:

**User Model**:
```typescript
interface User {
  id: string; // Clerk user ID
  email: string;
  firstName: string;
  lastName: string;
  createdAt: Date;
  updatedAt: Date;
  preferences: UserPreferences;
}

interface UserPreferences {
  currency: string; // ISO currency code (default: 'USD')
  dateFormat: string; // Date display preference
  alertThresholds: {
    creditCard: number; // Credit utilization alert percentage
    lowBalance: number; // Low account balance threshold
  };
  notifications: {
    email: boolean;
    push: boolean;
    sms: boolean; // Future implementation
  };
}
```

**Account Model**:
```typescript
interface Account {
  id: string;
  userId: string;
  name: string;
  type: AccountType;
  balance: Decimal; // Using decimal.js for financial precision
  creditLimit?: Decimal; // Optional for bank accounts
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

enum AccountType {
  CHECKING = 'checking',
  SAVINGS = 'savings',
  INVESTMENT = 'investment',
  CREDIT_CARD = 'credit_card',
  OTHER = 'other'
}
```

**Transaction Model**:
```typescript
interface Transaction {
  id: string;
  userId: string;
  accountId: string;
  amount: Decimal; // Positive for income/credits, negative for expenses/debits
  description: string;
  categoryId: string;
  transactionDate: Date; // User-specified transaction date
  isRecurring: boolean;
  recurringPaymentId?: string; // Optional link to recurring payment
  receiptUrl?: string; // Optional receipt image URL
  createdAt: Date; // System creation timestamp
  updatedAt: Date;
}
```

**Category Model**:
```typescript
interface Category {
  id: string;
  userId: string;
  name: string;
  type: CategoryType;
  color: string; // Hex color code for UI consistency
  isDefault: boolean;
  parentId?: string; // For subcategories
  createdAt: Date;
  updatedAt: Date;
}

enum CategoryType {
  INCOME = 'income',
  EXPENSE = 'expense'
}
```

**RecurringPayment Model**:
```typescript
interface RecurringPayment {
  id: string;
  userId: string;
  accountId: string;
  name: string;
  amount: Decimal;
  frequency: PaymentFrequency;
  nextDueDate: Date;
  categoryId: string;
  isActive: boolean;
  lastProcessed?: Date; // Last time payment was detected/processed
  createdAt: Date;
  updatedAt: Date;
}

enum PaymentFrequency {
  WEEKLY = 'weekly',
  MONTHLY = 'monthly',
  QUARTERLY = 'quarterly',
  YEARLY = 'yearly'
}
```

**Data Relationships**: 
- User has one-to-many with Accounts, Transactions, Categories, RecurringPayments
- Account has one-to-many with Transactions, RecurringPayments  
- Category has one-to-many with Transactions, RecurringPayments
- Category supports self-referencing for subcategories
- RecurringPayment generates multiple Transaction records over time
[Source: architecture/architecture.md#User Relationships, Account Relationships, etc.]

### API Specifications
**Database Security**: All database operations require proper user authentication and data isolation by userId [Source: architecture/architecture.md#REST API Specification]

**Connection Architecture**: Repository Pattern with service layer abstraction using Drizzle ORM [Source: architecture/architectural_patterns.md]

### Component Specifications
**Currency Handling**: Use decimal.js for financial precision in amount fields to prevent floating point errors [Source: architecture/tech_stack.md]
**Validation**: Zod for runtime schema validation and type-safe API boundaries [Source: architecture/tech_stack.md]

### File Locations
**Database Configuration**: Configure database connection in appropriate Next.js structure
**Schema Files**: Organize Drizzle schemas following project structure conventions
**Migration Files**: Set up migration directory for database versioning
**Service Layer**: Database services should follow repository pattern organization

### Testing Requirements
**Testing Stack**:
- Backend Testing: Vitest + Supertest for API endpoint testing with database integration tests [Source: architecture/tech_stack.md]
- Unit Testing: Test schema validation and database utilities [Source: architecture/tech_stack.md]

**Testing Approach**: Database integration tests, HTTP API testing, consistent testing framework with TypeScript support [Source: architecture/tech_stack.md]

### Technical Constraints
**Framework Version**: Next.js 15.4.6 with API Routes for serverless endpoints [Source: architecture/tech_stack.md]
**TypeScript**: Version 5.x for type-safe API development with shared types between frontend/backend [Source: architecture/tech_stack.md]
**Platform**: Vercel deployment with serverless functions, automatic deployment [Source: architecture/architecture.md#Platform and Infrastructure Choice]

**Database Requirements**: 
- ACID compliance for financial transactions [Source: architecture/tech_stack.md]
- Connection pooling for serverless scaling [Source: architecture/architecture.md]
- Proper data isolation and security [Source: architecture/architecture.md]

### Project Structure Notes
Implementation should follow existing Next.js 15 App Router structure. Database configuration and schemas should integrate cleanly with existing authentication system from Story 1.1.

### Testing
**Test Frameworks**: 
- Backend Testing: Vitest + Supertest for API endpoint testing and database integration [Source: architecture/tech_stack.md]
- Unit Testing: Schema validation, database utilities, and connection testing [Source: architecture/tech_stack.md]

**Test Requirements**: Database integration tests, migration testing, connection pooling verification, and data integrity constraint testing
**Specific Requirements**: Test financial precision with decimal operations, test user data isolation, and test proper constraint enforcement

## Change Log
| Date       | Version | Description                | Author |
|------------|---------|----------------------------|--------|
| 2025-08-11 | 1.0     | Initial story creation     | Bob (SM) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*Results from QA Agent QA review will be populated here after story completion*
